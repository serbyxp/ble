<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>ESP32 BLE HID Control Panel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark light;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background: #0f121d;
      color: #f5f7ff;
    }

    body {
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: radial-gradient(circle at top, #202742, #0a0d16 65%);
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: 1.7rem;
      letter-spacing: 0.04em;
    }

    section {
      background: rgba(20, 24, 36, 0.92);
      border: 1px solid rgba(90, 130, 255, 0.28);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 14px 36px rgba(6, 8, 18, 0.45);
    }

    .wifi-layout {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .wifi-status {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .wifi-status.error {
      color: #ff9aa0;
    }

    .wifi-network-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .wifi-network-list .empty {
      padding: 12px;
      border-radius: 10px;
      border: 1px dashed rgba(120, 150, 255, 0.3);
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.8;
    }

    label.wifi-network {
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: rgba(26, 30, 48, 0.85);
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    label.wifi-network:hover {
      border-color: rgba(160, 190, 255, 0.55);
      background: rgba(36, 40, 60, 0.92);
    }

    label.wifi-network input[type="radio"] {
      width: 18px;
      height: 18px;
    }

    label.wifi-network .ssid {
      font-weight: 600;
      font-size: 0.95rem;
    }

    label.wifi-network .meta {
      grid-column: 2;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    fieldset {
      border: 1px solid rgba(120, 150, 255, 0.22);
      border-radius: 10px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    legend {
      padding: 0 6px;
      font-size: 0.95rem;
      font-weight: 600;
    }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.92rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      flex: 1;
      min-width: 140px;
      padding: 0.5rem 0.6rem;
      border-radius: 8px;
      border: 1px solid rgba(110, 145, 255, 0.3);
      background: rgba(18, 22, 34, 0.96);
      color: inherit;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: rgba(150, 200, 255, 0.65);
      box-shadow: 0 0 0 2px rgba(120, 180, 255, 0.25);
    }

    button {
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid rgba(110, 145, 255, 0.35);
      background: linear-gradient(135deg, rgba(70, 110, 255, 0.9), rgba(90, 140, 255, 0.75));
      color: #fdfefe;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(50, 80, 220, 0.35);
    }

    button.secondary {
      background: rgba(70, 80, 110, 0.85);
      border-color: rgba(120, 140, 200, 0.4);
    }

    button.active {
      background: linear-gradient(135deg, rgba(100, 200, 80, 0.9), rgba(80, 180, 60, 0.85));
      border-color: rgba(120, 220, 100, 0.5);
    }

    .grid {
      display: grid;
      gap: 0.6rem;
    }

    .grid.actions {
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    .grid.media {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .grid.mouse {
      grid-template-columns: repeat(3, minmax(85px, 1fr));
      justify-items: stretch;
      align-items: center;
    }

    .log {
      max-height: 260px;
      overflow-y: auto;
      padding: 0.85rem;
      border-radius: 10px;
      border: 1px solid rgba(120, 150, 255, 0.22);
      background: rgba(16, 20, 32, 0.9);
      font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
      font-size: 0.84rem;
      line-height: 1.35;
    }

    .log-entry {
      display: grid;
      grid-template-columns: auto auto 1fr;
      gap: 0.4rem;
      align-items: baseline;
      padding: 0.2rem 0;
    }

    .log-entry .time {
      opacity: 0.6;
    }

    .log-entry .direction {
      width: 1.5rem;
      text-align: center;
      font-weight: 700;
    }

    .log-entry.send .direction {
      color: #85a9ff;
    }

    .log-entry.recv .direction {
      color: #6fe7c8;
    }

    .log-entry.info .direction {
      color: #ffd479;
    }

    .log-entry.error .direction {
      color: #ff7a8a;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .row>* {
      flex: 1 1 220px;
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .transport-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .transport-option {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-weight: 600;
    }

    .transport-option input[type="radio"] {
      width: 18px;
      height: 18px;
    }

    .transport-details {
      display: none;
      flex-direction: column;
      gap: 0.5rem;
      margin-left: 1.9rem;
    }

    .transport-details.active {
      display: flex;
    }

    .status {
      font-size: 0.9rem;
      opacity: 0.82;
    }

    .status.error {
      color: #ff9aa0;
    }

    small {
      font-size: 0.82rem;
      opacity: 0.7;
    }

    #viewer-container {
      position: relative;
      width: 100%;
      overflow: hidden;
      border-radius: 12px;
      border: 1px solid rgba(120, 160, 255, 0.28);
      background: #05060e;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #viewer-container.landscape {
      aspect-ratio: 16 / 9;
      max-height: 70vh;
    }

    #viewer-container.portrait {
      aspect-ratio: 9 / 16;
      max-height: 80vh;
      max-width: 45vh;
      margin: 0 auto;
    }

    #remote-video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    #viewer-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      outline: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      padding: 0.45rem;
      background: rgba(10, 12, 22, 0.12);
    }

    #viewer-overlay.inactive {
      cursor: default;
    }

    #viewer-overlay.disabled {
      cursor: not-allowed;
      pointer-events: none;
      background: rgba(10, 12, 22, 0.4);
    }

    #overlay-hint {
      background: rgba(8, 12, 22, 0.75);
      padding: 0.35rem 0.65rem;
      border-radius: 6px;
      font-size: 0.8rem;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }

    #viewer-overlay.active #overlay-hint {
      opacity: 0.35;
    }

    @media (max-width: 860px) {
      body {
        padding: 12px;
      }

      section {
        padding: 12px 14px;
      }

      .grid.mouse {
        grid-template-columns: repeat(3, minmax(70px, 1fr));
      }

      button {
        font-size: 0.85rem;
      }
    }
  </style>
</head>

<body>
  <h1>ESP32 BLE HID Control Panel</h1>

  <section id="wifi-section">
    <fieldset class="wifi-layout">
      <legend>Wi-Fi Setup</legend>
      <p id="wifi-status" class="wifi-status">Scan to find available Wi-Fi networks.</p>
      <div id="wifi-network-list" class="wifi-network-list">
        <div class="empty">No scan results yet.</div>
      </div>
      <div class="row">
        <label>Manual SSID <input type="text" id="wifi-custom-ssid" placeholder="Enter SSID manually" autocomplete="off" /></label>
        <label>Password <input type="password" id="wifi-password" placeholder="Network password" autocomplete="current-password" /></label>
      </div>
      <div class="row">
        <button type="button" id="wifi-refresh" class="secondary">Scan Networks</button>
        <button type="button" id="wifi-connect">Connect</button>
      </div>
      <small>Scanning and connection happen on the ESP32. Selecting a network overrides the manual SSID field.</small>
    </fieldset>
  </section>

  <section id="transport-section">
    <form id="transport-form" class="column">
      <fieldset>
        <legend>Command Transport</legend>
        <div class="transport-options">
          <label class="transport-option">
            <input type="radio" name="transport-mode" value="uart" checked />
            UART Serial
          </label>
          <div id="uart-details" class="transport-details active">
            <label>
              Baud
              <select id="uart-baud">
                <option value="115200" selected>115200</option>
                <option value="230400">230400</option>
                <option value="460800">460800</option>
              </select>
            </label>
            <small>Commands are received over the USB serial connection.</small>
          </div>
          <label class="transport-option">
            <input type="radio" name="transport-mode" value="websocket" />
            WebSocket
          </label>
          <div id="websocket-details" class="transport-details">
            <small>Commands stream over Wi-Fi via the /ws WebSocket endpoint.</small>
          </div>
        </div>
        <button type="submit" id="transport-save">Save</button>
      </fieldset>
    </form>
    <div class="status" id="transport-status">Loading transport settings…</div>
  </section>

  <section>
    <fieldset>
      <legend>Remote Viewer</legend>
      <div class="row">
        <label>Video Stream URL <input type="text" id="video-url-input"
            placeholder="http://192.168.1.100:7100/stream.mjpg" /></label>
        <button type="button" id="video-load-button">Load Stream</button>
      </div>
      <div id="viewer-container" class="landscape">
        <video id="remote-video" autoplay muted playsinline></video>
        <div id="viewer-overlay" class="inactive disabled" tabindex="0">
          <div id="overlay-hint">Control disabled</div>
        </div>
      </div>
      <div class="row">
        <button type="button" id="capture-toggle" class="secondary">Start Capture</button>
        <button type="button" class="secondary" id="pointer-lock-toggle">Enable Pointer Lock</button>
        <button type="button" class="secondary" id="overlay-release">Release All</button>
        <button type="button" class="secondary" id="orientation-toggle">Orientation: Auto</button>
        <label>
          Sensitivity
          <input type="number" id="overlay-sensitivity" value="1.0" min="0.1" max="10" step="0.1" />
        </label>
      </div>
      <small>
        UxPlay streams at 1920x1080 (landscape) or 1080x1920 (portrait). Enter stream URL and click "Load Stream".
        Use "Start Capture" then click overlay to enable pointer lock for best mouse response.
      </small>
    </fieldset>
  </section>

  <section>
    <fieldset>
      <legend>Keyboard Text Output</legend>
      <textarea id="text-input" placeholder="Type text to send..."></textarea>
      <div class="row">
        <label><input type="checkbox" id="text-newline" checked /> Append newline</label>
        <label>Character delay (ms) <input type="number" id="text-delay" value="6" min="0" max="1000" /></label>
        <button type="button" id="text-send">Send Text</button>
        <button type="button" id="paste-clipboard" class="secondary">Paste from Clipboard</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Quick Key Combos</legend>
      <div class="grid actions" id="combo-buttons">
        <button type="button" data-keys="ENTER" data-hold="40">Enter</button>
        <button type="button" data-keys="CTRL,ALT,DELETE" data-hold="150">Ctrl + Alt + Delete</button>
        <button type="button" data-keys="CTRL,C" data-hold="60">Copy (Ctrl+C)</button>
        <button type="button" data-keys="CTRL,V" data-hold="60">Paste (Ctrl+V)</button>
        <button type="button" data-keys="CTRL,Z" data-hold="60">Undo (Ctrl+Z)</button>
        <button type="button" data-keys="ALT,TAB" data-hold="200">Alt + Tab</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Media Keys</legend>
      <div class="grid media" id="media-buttons">
        <button type="button" data-key="KEY_MEDIA_PLAY_PAUSE">Play / Pause</button>
        <button type="button" data-key="KEY_MEDIA_STOP">Stop</button>
        <button type="button" data-key="KEY_MEDIA_PREVIOUS_TRACK">Previous</button>
        <button type="button" data-key="KEY_MEDIA_NEXT_TRACK">Next</button>
        <button type="button" data-key="KEY_MEDIA_VOLUME_DOWN">Volume -</button>
        <button type="button" data-key="KEY_MEDIA_VOLUME_UP">Volume +</button>
        <button type="button" data-key="KEY_MEDIA_MUTE">Mute</button>
      </div>
    </fieldset>
  </section>

  <section>
    <fieldset>
      <legend>Mouse Controls</legend>
      <div class="row">
        <label>Step (px) <input type="number" id="mouse-step" value="25" min="1" max="200" /></label>
        <label>Scroll step <input type="number" id="scroll-step" value="2" min="1" max="50" /></label>
      </div>
      <div class="grid mouse" id="move-buttons">
        <span></span><button type="button" data-dx="0" data-dy="-1">▲</button><span></span>
        <button type="button" data-dx="-1" data-dy="-1">◄▲</button>
        <button type="button" data-wheel="1" class="secondary">Scroll ▲</button>
        <button type="button" data-dx="1" data-dy="-1">▲►</button>
        <button type="button" data-dx="-1" data-dy="0">◄</button>
        <button type="button" data-pan="-1" class="secondary">Pan ◄</button>
        <button type="button" data-dx="1" data-dy="0">►</button>
        <button type="button" data-dx="-1" data-dy="1">◄▼</button>
        <button type="button" data-dx="0" data-dy="1">▼</button>
        <button type="button" data-dx="1" data-dy="1">▼►</button>
      </div>
      <div class="grid actions" id="click-buttons">
        <button type="button" data-action="click" data-buttons="left">Left Click</button>
        <button type="button" data-action="click" data-buttons="right">Right Click</button>
        <button type="button" data-action="click" data-buttons="middle">Middle Click</button>
        <button type="button" data-action="press" data-buttons="left">Press Left</button>
        <button type="button" data-action="release" data-buttons="left">Release Left</button>
        <button type="button" data-action="releaseAll" class="secondary">Release All Buttons</button>
      </div>
    </fieldset>
  </section>

  <section>
    <fieldset>
      <legend>Command Log</legend>
      <div id="log" class="log"></div>
      <div class="row">
        <button type="button" class="secondary" id="log-clear">Clear Log</button>
        <label><input type="checkbox" id="log-mouse-moves" /> Log mouse moves</label>
      </div>
    </fieldset>
  </section>

  <script>
    (() => {
      const videoUrlInput = document.getElementById("video-url-input");
      const videoLoadButton = document.getElementById("video-load-button");
      const remoteVideo = document.getElementById("remote-video");
      const textInput = document.getElementById("text-input");
      const textNewline = document.getElementById("text-newline");
      const textDelay = document.getElementById("text-delay");
      const textSendButton = document.getElementById("text-send");
      const comboButtons = document.getElementById("combo-buttons");
      const mediaButtons = document.getElementById("media-buttons");
      const moveButtons = document.getElementById("move-buttons");
      const clickButtons = document.getElementById("click-buttons");
      const mouseStep = document.getElementById("mouse-step");
      const scrollStep = document.getElementById("scroll-step");
      const logContainer = document.getElementById("log");
      const logClear = document.getElementById("log-clear");
      const logMouseMoves = document.getElementById("log-mouse-moves");
      const captureToggle = document.getElementById("capture-toggle");
      const pointerLockToggle = document.getElementById("pointer-lock-toggle");
      const overlayRelease = document.getElementById("overlay-release");
      const orientationToggle = document.getElementById("orientation-toggle");
      const overlaySensitivity = document.getElementById("overlay-sensitivity");
      const viewerContainer = document.getElementById("viewer-container");
      const overlay = document.getElementById("viewer-overlay");
      const overlayHint = document.getElementById("overlay-hint");
      const wifiSection = document.getElementById("wifi-section");
      const wifiStatus = document.getElementById("wifi-status");
      const wifiNetworkList = document.getElementById("wifi-network-list");
      const wifiCustomSsid = document.getElementById("wifi-custom-ssid");
      const wifiPassword = document.getElementById("wifi-password");
      const wifiRefreshButton = document.getElementById("wifi-refresh");
      const wifiConnectButton = document.getElementById("wifi-connect");
      const transportForm = document.getElementById("transport-form");
      const transportStatus = document.getElementById("transport-status");
      const transportSaveButton = document.getElementById("transport-save");
      const transportModeInputs = Array.from(document.querySelectorAll("input[name='transport-mode']"));
      const uartDetails = document.getElementById("uart-details");
      const websocketDetails = document.getElementById("websocket-details");
      const uartBaud = document.getElementById("uart-baud");

      let websocket = null;
      let wsRequestId = 0;
      let captureEnabled = false;
      let pointerLockEnabled = false;
      let orientationMode = "auto";
      let videoPlaying = false;
      let transportMode = "uart";

      const mouseButtonMap = ["left", "middle", "right", "back", "forward"];

      function updateTransportDetails(mode) {
        if (uartDetails) {
          uartDetails.classList.toggle("active", mode === "uart");
        }
        if (websocketDetails) {
          websocketDetails.classList.toggle("active", mode === "websocket");
        }
      }

      function setTransportRadios(mode) {
        transportModeInputs.forEach((input) => {
          input.checked = input.value === mode;
        });
      }

      function setTransportStatus(text, isError = false) {
        if (!transportStatus) return;
        transportStatus.textContent = text;
        transportStatus.classList.toggle("error", Boolean(isError));
      }

      function formatTransportStatus(mode, baud) {
        if (mode === "websocket") {
          return "Active transport: WebSocket";
        }
        const baudLabel = baud || (uartBaud ? uartBaud.value : "115200");
        return `Active transport: UART @ ${baudLabel} baud`;
      }

      function applyActiveTransport(mode, baud) {
        transportMode = mode;
        setTransportRadios(mode);
        if (typeof baud === "number" && uartBaud) {
          uartBaud.value = String(baud);
        }
        updateTransportDetails(mode);
        setTransportStatus(formatTransportStatus(mode, typeof baud === "number" ? String(baud) : null));
        if (mode === "websocket") {
          ensureWebsocket();
        } else {
          closeWebsocket();
        }
        updateOverlayState();
      }

      transportModeInputs.forEach((input) => {
        input.addEventListener("change", () => {
          const mode = input.value === "websocket" ? "websocket" : "uart";
          updateTransportDetails(mode);
        });
      });

      function setWifiStatus(message, isError = false) {
        if (!wifiStatus) return;
        wifiStatus.textContent = message;
        wifiStatus.classList.toggle("error", Boolean(isError));
      }

      function renderWifiNetworks(networks) {
        if (!wifiNetworkList) return;
        wifiNetworkList.innerHTML = "";
        if (!networks.length) {
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "No networks found. Try scanning again.";
          wifiNetworkList.appendChild(empty);
          return;
        }

        networks.forEach((network, index) => {
          const id = `wifi-net-${index}`;
          const label = document.createElement("label");
          label.className = "wifi-network";
          const input = document.createElement("input");
          input.type = "radio";
          input.name = "wifi-ssid";
          input.value = network.ssid || "";
          input.id = id;
          if (index === 0) {
            input.checked = true;
          }
          input.addEventListener("change", () => {
            if (input.checked && wifiCustomSsid) {
              wifiCustomSsid.value = "";
            }
          });

          const ssid = document.createElement("span");
          ssid.className = "ssid";
          ssid.textContent = network.ssid || "(Hidden SSID)";

          const meta = document.createElement("span");
          meta.className = "meta";
          const auth = network.auth && network.auth !== "open" ? network.auth.toUpperCase() : "OPEN";
          const channel = network.channel ? `Ch ${network.channel}` : "";
          const strength = typeof network.rssi === "number" ? `${network.rssi} dBm` : "";
          meta.textContent = [auth, channel, strength].filter(Boolean).join(" • ");

          label.append(input, ssid, meta);
          wifiNetworkList.appendChild(label);
        });
      }

      async function loadWifiNetworks() {
        if (!wifiRefreshButton) return;
        wifiRefreshButton.disabled = true;
        setWifiStatus("Scanning for networks…");
        try {
          const response = await fetch("/scan", { headers: { Accept: "application/json" } });
          if (!response.ok) {
            throw new Error(`${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          const networks = Array.isArray(data.networks) ? data.networks : [];
          networks.sort((a, b) => (b.rssi ?? -100) - (a.rssi ?? -100));
          renderWifiNetworks(networks);
          if (networks.length) {
            setWifiStatus("Select a network or enter an SSID manually.");
          } else {
            setWifiStatus("No networks found. You can enter an SSID manually or rescan.");
          }
        } catch (error) {
          console.error(error);
          setWifiStatus(`Scan failed: ${error instanceof Error ? error.message : String(error)}`, true);
          if (wifiNetworkList) {
            wifiNetworkList.innerHTML = "";
            const empty = document.createElement("div");
            empty.className = "empty";
            empty.textContent = "Unable to load scan results.";
            wifiNetworkList.appendChild(empty);
          }
        } finally {
          wifiRefreshButton.disabled = false;
        }
      }

      async function configureWifi(ssid, password) {
        if (!wifiConnectButton || !ssid) return;
        wifiConnectButton.disabled = true;
        if (wifiRefreshButton) {
          wifiRefreshButton.disabled = true;
        }
        setWifiStatus(`Connecting to ${ssid}…`);
        try {
          const response = await fetch("/configure", {
            method: "POST",
            headers: { "Content-Type": "application/json", Accept: "application/json" },
            body: JSON.stringify({ ssid, password })
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok || (data && data.status === "error")) {
            const message = data && data.message ? data.message : `${response.status} ${response.statusText}`;
            throw new Error(message);
          }
          setWifiStatus(`Connected to ${ssid}. The ESP32 will attempt to join the network.`);
        } catch (error) {
          console.error(error);
          setWifiStatus(`Connection failed: ${error instanceof Error ? error.message : String(error)}`, true);
        } finally {
          wifiConnectButton.disabled = false;
          if (wifiRefreshButton) {
            wifiRefreshButton.disabled = false;
          }
        }
      }

      const formatTime = () => new Date().toLocaleTimeString();

      if (wifiSection) {
        if (wifiRefreshButton) {
          wifiRefreshButton.addEventListener("click", () => {
            loadWifiNetworks();
          });
        }

        if (wifiConnectButton) {
          wifiConnectButton.addEventListener("click", () => {
            const selected = wifiSection.querySelector('input[name="wifi-ssid"]:checked');
            let ssid = (wifiCustomSsid && wifiCustomSsid.value.trim()) || "";
            if (!ssid && selected) {
              ssid = selected.value;
            }
            if (!ssid) {
              setWifiStatus("Choose a network or enter an SSID.", true);
              if (wifiCustomSsid) {
                wifiCustomSsid.focus();
              }
              return;
            }
            configureWifi(ssid, wifiPassword ? wifiPassword.value : "");
          });
        }

        if (wifiCustomSsid) {
          wifiCustomSsid.addEventListener("input", () => {
            if (!wifiSection) return;
            if (wifiCustomSsid.value.trim().length) {
              const selected = wifiSection.querySelector('input[name="wifi-ssid"]:checked');
              if (selected) {
                selected.checked = false;
              }
            }
          });
        }

        loadWifiNetworks();
      }

      function appendLog(direction, message, type = "info") {
        if (!logContainer) return;
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        const time = document.createElement("span");
        time.className = "time";
        time.textContent = formatTime();
        const dir = document.createElement("span");
        dir.className = "direction";
        dir.textContent = direction;
        const body = document.createElement("pre");
        body.textContent = message;
        body.style.margin = "0";
        body.style.whiteSpace = "pre-wrap";
        entry.append(time, dir, body);
        logContainer.append(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
      }

      function logSend(message) { appendLog("→", message, "send"); }
      function logRecv(message) { appendLog("←", message, "recv"); }
      function logInfo(message) { appendLog("i", message, "info"); }
      function logError(message) { appendLog("!", message, "error"); }

      async function apiGet(path) {
        const response = await fetch(path, { headers: { Accept: "application/json" } });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `${response.status} ${response.statusText}`);
        }
        return response.json();
      }

      async function apiPost(path, payload) {
        const response = await fetch(path, {
          method: "POST",
          headers: { "Content-Type": "application/json", Accept: "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `${response.status} ${response.statusText}`);
        }
        return response.json();
      }

      async function sendText() {
        const text = textInput.value;
        if (!text) {
          logInfo("Nothing to send – textarea is empty");
          return;
        }
        const payload = {
          text,
          newline: Boolean(textNewline.checked),
          charDelayMs: Number.parseInt(textDelay.value, 10) || 0,
          listen: 0.5
        };
        logSend(`POST /api/text\n${JSON.stringify(payload, null, 2)}`);
        try {
          const data = await apiPost("/api/text", payload);
          logRecv(JSON.stringify(data, null, 2));
        } catch (err) {
          logError(err instanceof Error ? err.message : String(err));
        }
      }

      async function sendKeyboard(action, extra = {}) {
        const payload = { action, ...extra, listen: 0.3 };
        logSend(`POST /api/keyboard\n${JSON.stringify(payload, null, 2)}`);
        try {
          const data = await apiPost("/api/keyboard", payload);
          logRecv(JSON.stringify(data, null, 2));
        } catch (err) {
          logError(err instanceof Error ? err.message : String(err));
        }
      }

      async function sendMedia(key) {
        const payload = { key, listen: 0.3 };
        logSend(`POST /api/media\n${JSON.stringify(payload, null, 2)}`);
        try {
          const data = await apiPost("/api/media", payload);
          logRecv(JSON.stringify(data, null, 2));
        } catch (err) {
          logError(err instanceof Error ? err.message : String(err));
        }
      }

      async function sendMouse(payload) {
        const requestPayload = { ...payload, listen: 0.1 };
        logSend(`POST /api/mouse\n${JSON.stringify(requestPayload, null, 2)}`);
        try {
          const data = await apiPost("/api/mouse", requestPayload);
          logRecv(JSON.stringify(data, null, 2));
        } catch (err) {
          logError(err instanceof Error ? err.message : String(err));
        }
      }

      function closeWebsocket() {
        if (!websocket) return;
        try {
          websocket.close();
        } catch (err) {
          console.warn("Failed to close WebSocket", err);
        }
        websocket = null;
      }

      function ensureWebsocket() {
        if (transportMode !== "websocket") {
          closeWebsocket();
          updateOverlayState();
          return;
        }
        if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
          return;
        }
        const scheme = window.location.protocol === "https:" ? "wss" : "ws";
        websocket = new WebSocket(`${scheme}://${window.location.host}/ws`);

        websocket.addEventListener("open", () => {
          logInfo("WebSocket connected");
          updateOverlayState();
        });

        websocket.addEventListener("message", (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.status === "error") {
              logError(JSON.stringify(data, null, 2));
            } else if (data.event === "transport_mode") {
              const detail = typeof data.detail === "string" ? data.detail : "";
              logInfo(`Transport event: ${detail}`);
              loadTransportConfig();
            } else if (data.type !== "ping") {
              logRecv(JSON.stringify(data, null, 2));
            }
          } catch (err) {
            logRecv(event.data);
          }
        });

        websocket.addEventListener("close", () => {
          logInfo("WebSocket disconnected");
          websocket = null;
          updateOverlayState();
          if (transportMode === "websocket") {
            setTimeout(ensureWebsocket, 1500);
          }
        });

        websocket.addEventListener("error", (event) => {
          logError(`WebSocket error: ${event instanceof ErrorEvent ? event.message : "unknown"}`);
        });
      }

      function sendWs(type, payload) {
        if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
        const message = {
          type,
          requestId: ++wsRequestId,
          ...payload,
          listen: 0
        };
        websocket.send(JSON.stringify(message));
      }

      function shouldForwardInput() {
        return transportMode === "websocket" && captureEnabled && websocket && websocket.readyState === WebSocket.OPEN;
      }

      function updateOverlayHint() {
        if (!captureEnabled) {
          overlayHint.textContent = "Capture off – click Start Capture";
        } else if (transportMode !== "websocket") {
          overlayHint.textContent = "WebSocket transport disabled";
        } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
          overlayHint.textContent = "WebSocket not connected";
        } else if (pointerLockEnabled && document.pointerLockElement === overlay) {
          overlayHint.textContent = "Locked – Esc to release";
        } else if (pointerLockEnabled) {
          overlayHint.textContent = "Click to lock pointer";
        } else {
          overlayHint.textContent = "Capturing input";
        }
      }

      function updateOverlayState() {
        const canCapture = transportMode === "websocket" && websocket && websocket.readyState === WebSocket.OPEN;
        overlay.classList.toggle("disabled", !canCapture);
        overlay.classList.toggle("inactive", !captureEnabled);
        overlay.classList.toggle("active", captureEnabled);
        updateOverlayHint();
      }

      function updateOrientation() {
        if (orientationMode === "auto") {
          if (videoPlaying && remoteVideo.videoWidth && remoteVideo.videoHeight) {
            const isPortrait = remoteVideo.videoHeight > remoteVideo.videoWidth;
            viewerContainer.className = isPortrait ? "portrait" : "landscape";
          } else {
            viewerContainer.className = "landscape";
          }
        } else {
          viewerContainer.className = orientationMode;
        }
      }

      function pointerButtonName(event) {
        return mouseButtonMap[event.button] || "left";
      }

      if (transportForm) {
        transportForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          if (transportSaveButton) {
            transportSaveButton.disabled = true;
          }
          const formData = new FormData(transportForm);
          const selected = formData.get("transport-mode") === "websocket" ? "websocket" : "uart";
          const payload = { mode: selected };
          if (selected === "uart" && uartBaud) {
            payload.baud = Number.parseInt(uartBaud.value, 10) || 115200;
          }
          setTransportStatus("Saving…");
          logSend(`POST /api/transport\n${JSON.stringify(payload, null, 2)}`);
          try {
            const data = await apiPost("/api/transport", payload);
            const mode = data.mode === "websocket" ? "websocket" : "uart";
            applyActiveTransport(mode, typeof data.baud === "number" ? data.baud : undefined);
            const summary = mode === "websocket" ? "WebSocket" : `UART @ ${data.baud} baud`;
            logInfo(`Transport updated: ${summary}`);
            logRecv(JSON.stringify(data, null, 2));
          } catch (err) {
            const message = err instanceof Error ? err.message : String(err);
            setTransportStatus(`Failed to save: ${message}`, true);
            logError(message);
            setTransportRadios(transportMode);
            updateTransportDetails(transportMode);
          } finally {
            if (transportSaveButton) {
              transportSaveButton.disabled = false;
            }
          }
        });
      }

      videoLoadButton.addEventListener("click", () => {
        const url = videoUrlInput.value.trim();
        if (!url) {
          logError("Video URL is empty");
          return;
        }
        remoteVideo.src = url;
        logInfo(`Loading video stream: ${url}`);
      });

      remoteVideo.addEventListener("loadedmetadata", () => {
        videoPlaying = true;
        logInfo(`Video loaded: ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`);
        updateOrientation();
      });

      remoteVideo.addEventListener("play", () => {
        videoPlaying = true;
        updateOrientation();
      });

      remoteVideo.addEventListener("pause", () => {
        videoPlaying = false;
      });

      remoteVideo.addEventListener("ended", () => {
        videoPlaying = false;
      });

      captureToggle.addEventListener("click", () => {
        captureEnabled = !captureEnabled;
        captureToggle.textContent = captureEnabled ? "Stop Capture" : "Start Capture";
        captureToggle.classList.toggle("active", captureEnabled);
        updateOverlayState();
        if (captureEnabled) {
          setTimeout(() => overlay.focus(), 100);
        }
      });

      pointerLockToggle.addEventListener("click", () => {
        pointerLockEnabled = !pointerLockEnabled;
        pointerLockToggle.textContent = pointerLockEnabled ? "Disable Pointer Lock" : "Enable Pointer Lock";
        pointerLockToggle.classList.toggle("active", pointerLockEnabled);
        if (!pointerLockEnabled && document.pointerLockElement === overlay) {
          document.exitPointerLock();
        }
        updateOverlayHint();
      });

      overlayRelease.addEventListener("click", () => {
        if (!shouldForwardInput()) return;
        sendWs("keyboard_release_all", {});
        sendWs("mouse_release_all", {});
        logInfo("Released all keyboard and mouse buttons");
      });

      orientationToggle.addEventListener("click", () => {
        const modes = ["auto", "landscape", "portrait"];
        const currentIndex = modes.indexOf(orientationMode);
        orientationMode = modes[(currentIndex + 1) % modes.length];
        orientationToggle.textContent = `Orientation: ${orientationMode.charAt(0).toUpperCase() + orientationMode.slice(1)}`;
        updateOrientation();
      });

      overlay.addEventListener("click", () => {
        if (overlay.classList.contains("disabled") || !pointerLockEnabled) return;
        overlay.requestPointerLock();
      });

      document.addEventListener("pointerlockchange", () => {
        updateOverlayHint();
      });

      textSendButton.addEventListener("click", sendText);
      textInput.addEventListener("keydown", (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
          event.preventDefault();
          sendText();
        }
      });

      comboButtons.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-keys]");
        if (!button) return;
        const keys = button.dataset.keys.split(",").map((key) => key.trim()).filter(Boolean);
        const hold = Number.parseInt(button.dataset.hold || "80", 10) || 80;
        sendKeyboard("tap", { keys, holdMs: hold });
      });

      mediaButtons.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-key]");
        if (!button) return;
        sendMedia(button.dataset.key);
      });

      moveButtons.addEventListener("click", (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const dx = Number.parseInt(button.dataset.dx || "0", 10) * (Number.parseInt(mouseStep.value, 10) || 0);
        const dy = Number.parseInt(button.dataset.dy || "0", 10) * (Number.parseInt(mouseStep.value, 10) || 0);
        const wheel = Number.parseInt(button.dataset.wheel || "0", 10) * (Number.parseInt(scrollStep.value, 10) || 0);
        const pan = Number.parseInt(button.dataset.pan || "0", 10) * (Number.parseInt(scrollStep.value, 10) || 0);
        if (dx === 0 && dy === 0 && wheel === 0 && pan === 0) return;
        sendMouse({ action: "move", dx, dy, wheel, pan });
      });

      clickButtons.addEventListener("click", (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action || "click";
        if (action === "releaseAll" || action === "release_all") {
          sendMouse({ action: "releaseAll" });
          return;
        }
        const buttons = (button.dataset.buttons || "left").split(",").map((value) => value.trim()).filter(Boolean);
        sendMouse({ action, buttons });
      });

      logClear.addEventListener("click", () => {
        logContainer.innerHTML = "";
      });

      let mouseMovePending = false;
      let pendingDx = 0;
      let pendingDy = 0;

      function flushMouseMove() {
        if (!mouseMovePending) return;
        mouseMovePending = false;
        if (pendingDx === 0 && pendingDy === 0) return;

        sendWs("mouse_move", { dx: pendingDx, dy: pendingDy });
        if (logMouseMoves.checked) {
          logSend(`WS mouse_move dx:${pendingDx} dy:${pendingDy}`);
        }
        pendingDx = 0;
        pendingDy = 0;
      }

      overlay.addEventListener("mouseenter", () => {
        if (captureEnabled) {
          overlay.focus();
        }
      });

      overlay.addEventListener("mousemove", (event) => {
        if (!shouldForwardInput()) return;

        const sensitivity = Number.parseFloat(overlaySensitivity.value) || 1.0;
        const dx = Math.round(event.movementX * sensitivity);
        const dy = Math.round(event.movementY * sensitivity);

        if (dx === 0 && dy === 0) return;

        pendingDx += dx;
        pendingDy += dy;

        if (!mouseMovePending) {
          mouseMovePending = true;
          requestAnimationFrame(flushMouseMove);
        }
      });

      overlay.addEventListener("wheel", (event) => {
        if (!shouldForwardInput()) return;
        event.preventDefault();
        const amount = Number.parseInt(scrollStep.value, 10) || 1;
        const wheel = -Math.sign(event.deltaY) * amount;
        const pan = Math.sign(event.deltaX) * amount;
        if (wheel === 0 && pan === 0) return;
        sendWs("mouse_move", { dx: 0, dy: 0, wheel, pan });
      });

      overlay.addEventListener("mousedown", (event) => {
        if (!shouldForwardInput()) return;
        event.preventDefault();
        overlay.focus();
        const buttonName = pointerButtonName(event);
        sendWs("mouse_press", { buttons: [buttonName] });
      });

      overlay.addEventListener("mouseup", (event) => {
        if (!shouldForwardInput()) return;
        event.preventDefault();
        const buttonName = pointerButtonName(event);
        sendWs("mouse_release", { buttons: [buttonName] });
      });

      overlay.addEventListener("contextmenu", (event) => {
        event.preventDefault();
      });

      const keyMap = {
        Control: "CTRL",
        Alt: "ALT",
        Shift: "SHIFT",
        Meta: "GUI",
        " ": "SPACE",
        Enter: "ENTER",
        Tab: "TAB",
        Escape: "ESC",
        ArrowUp: "UP",
        ArrowDown: "DOWN",
        ArrowLeft: "LEFT",
        ArrowRight: "RIGHT",
        Backspace: "BACKSPACE",
        Delete: "DELETE",
        Home: "HOME",
        End: "END",
        PageUp: "PAGE_UP",
        PageDown: "PAGE_DOWN",
        Insert: "INSERT",
        CapsLock: "CAPS_LOCK",
        F1: "F1", F2: "F2", F3: "F3", F4: "F4",
        F5: "F5", F6: "F6", F7: "F7", F8: "F8",
        F9: "F9", F10: "F10", F11: "F11", F12: "F12",
      };

      const modifierKeys = new Set(["CTRL", "ALT", "SHIFT", "GUI"]);
      const heldModifiers = new Set();

      function translateKey(event) {
        // Check if it's a special key (including space)
        if (keyMap[event.key]) {
          return keyMap[event.key];
        }

        // For printable characters, use event.key directly (it already has shift applied)
        if (event.key.length === 1) {
          return event.key;
        }

        // Fallback for other keys
        if (event.code && event.code.startsWith("Key")) {
          return event.code.slice(3).toUpperCase();
        }
        if (event.code && event.code.startsWith("Digit")) {
          return event.code.slice(5);
        }

        return null;
      }

      overlay.addEventListener("keydown", (event) => {
        if (!shouldForwardInput()) return;
        if (event.repeat) {
          event.preventDefault();
          return;
        }

        const key = translateKey(event);
        if (!key) return;

        event.preventDefault();
        event.stopPropagation();

        // Track modifier keys
        if (modifierKeys.has(key)) {
          heldModifiers.add(key);
        }

        sendWs("keyboard_press", { keys: [key] });
        if (logMouseMoves.checked) {
          logSend(`WS keyboard_press: ${key}`);
        }
      });

      overlay.addEventListener("keyup", (event) => {
        if (!shouldForwardInput()) return;

        const key = translateKey(event);
        if (!key) return;

        event.preventDefault();
        event.stopPropagation();

        // Track modifier keys
        if (modifierKeys.has(key)) {
          heldModifiers.delete(key);
        }

        sendWs("keyboard_release", { keys: [key] });
        if (logMouseMoves.checked) {
          logSend(`WS keyboard_release: ${key}`);
        }
      });

      async function loadTransportConfig() {
        setTransportStatus("Loading transport settings…");
        try {
          logSend("GET /api/transport");
          const data = await apiGet("/api/transport");
          logRecv(JSON.stringify(data, null, 2));
          const mode = data.mode === "websocket" ? "websocket" : "uart";
          applyActiveTransport(mode, typeof data.baud === "number" ? data.baud : undefined);
          const summary = mode === "websocket" ? "WebSocket" : `UART @ ${data.baud} baud`;
          logInfo(`Active transport: ${summary}`);
        } catch (err) {
          const message = err instanceof Error ? err.message : String(err);
          setTransportStatus(`Unable to load transport: ${message}`, true);
          logError(message);
          transportMode = "uart";
          closeWebsocket();
          updateTransportDetails("uart");
          setTransportRadios("uart");
        }
        updateOverlayState();
      }

      async function initialise() {
        await loadTransportConfig();
      }

      initialise();
    })();
  </script>
</body>

</html>